#include "SM4_neon.h"
#include <string.h>
#include "TestFuns.h"



int Test_SM4ECB(void)
{

	SM4_CTX_Std mySM4CTX;
	static u8i Sm4ALIGN(akey[SM4_BLOCK_SIZE]) = { 0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,   0xfe,0xdc,0xba,0x98, 0x76,0x54,0x32,0x10 };
	static u8i Sm4ALIGN(refpl[SM4_BLOCK_SIZE]) = { 0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,   0xfe,0xdc,0xba,0x98, 0x76,0x54,0x32,0x10 };
	static u8i Sm4ALIGN(refcp[SM4_BLOCK_SIZE]) = { 0x68 ,0x1e ,0xdf ,0x34 ,0xd2 ,0x06 ,0x96 ,0x5e ,0x86 ,0xb3 ,0xe9 ,0x4f ,0x53 ,0x6e ,0x42 ,0x46 };
	static u8i Sm4ALIGN(refcp1000000[SM4_BLOCK_SIZE]) = { 0x59 ,0x52 ,0x98 ,0xc7 ,0xc6 ,0xfd ,0x27 ,0x1f ,0x04 ,0x02 ,0xf8 ,0x04 ,0xc3 ,0x3d ,0x3f ,0x66 };
	u8i Sm4ALIGN(out[16]);
	u8i Sm4ALIGN(rec[16]);
	int olen = 16;
	int i;
	int err = 0;
	Init_SM4CTX(&mySM4CTX, akey, iMODE_SM4_ECB, NULL);
	// KeySchedule_SM4(akey,RK);
	memset(out, 0, olen);
	SM4_EncStd_ECB(out, refpl, olen, &mySM4CTX);
	for (i = 0; i < olen; i++)
		printf("%02x ", out[i]);
	printf("    enc %s\n", memcmp(out, refcp, olen) ? "FAIL" : "PASS");
	err += (memcmp(out, refcp, olen) ? 1 : 0);
	SM4_DecStd_ECB(rec, refcp, olen, &mySM4CTX);
	for (i = 0; i < olen; i++)
		printf("%02x ", rec[i]);
	printf("    dec %s\n", memcmp(refpl, rec, olen) ? "FAIL" : "PASS");
	err += (memcmp(refpl, rec, olen) ? 1 : 0);
	Clear_SM4CTX(&mySM4CTX);

	return err;
}

int Test_SM4CBC(void)
{

	SM4_CTX_Std mySM4CTX;
	static unsigned char Sm4ALIGN(brefpl[256]) = {
0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb,0xcc,0xcc,0xcc,0xcc,0xdd,0xdd,0xdd,0xdd
,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb,
 0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb, 0xbb,0xbb,0xbb,0xbb };
	static unsigned char Sm4ALIGN(bkey[SM4_BLOCK_SIZE]) = { 0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,   0xfe,0xdc,0xba,0x98, 0x76,0x54,0x32,0x10 };
	static unsigned char Sm4ALIGN(iv[16]) = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F };
	static unsigned char Sm4ALIGN(reccbc[256]) = {
	0x78,0xEB,0xB1,0x1C,0xC4,0x0B,0x0A,0x48,0x31,0x2A,0xAE,0xB2,0x04,0x02,0x44,0xCB
	,0x4C,0xB7,0x01,0x69,0x51,0x90,0x92,0x26,0x97,0x9B,0x0D,0x15,0xDC,0x6A,0x8F,0x6D };
	int i, err = 0;
	int outlen;
	unsigned char Sm4ALIGN(tv_cipher[256]);
	unsigned char Sm4ALIGN(tv_cipher1[256]);
	unsigned char Sm4ALIGN(tv_plain[256]);
	unsigned char Sm4ALIGN(tv_plain1[256]);
	int dlen = 32;
	//KeySchedule_SM4(bkey,RK); 
	Init_SM4CTX(&mySM4CTX, bkey, iMODE_SM4_CBC, iv);

	outlen = SM4_EncStd_CBC(tv_cipher, brefpl, dlen, &mySM4CTX);
	for (int i = 0; i < outlen; i++)
		printf("%02x ", tv_cipher[i]); printf("\n");
	i = (memcmp(tv_cipher, reccbc, 32) ? 1 : 0);
	printf(" SM4  CBC ENC test %s\n", i ? "FAIL" : "PASS");
	memset(tv_plain, 0, dlen);
	outlen = SM4_DecStd_CBC(tv_plain, reccbc, dlen, &mySM4CTX);
	for (int i = 0; i < outlen; i++)
		printf("%02x ", tv_plain[i]); printf("\n");
	i = (memcmp(tv_plain, brefpl, 32) ? 1 : 0);
	printf(" SM4  CBC DEC test %s\n", i ? "FAIL" : "PASS");
	err += i;
	dlen = 256;
	for (int i = 0; i < 256; i++)
		brefpl[i] = i;
	outlen = SM4_EncStd_CBC(tv_cipher, brefpl, dlen, &mySM4CTX);
	outlen = SM4_DecStd_CBC(tv_plain, tv_cipher, dlen, &mySM4CTX);
	outlen = SM4_DecNeon_CBC(tv_plain1, tv_cipher, dlen, &mySM4CTX);

	for (int i = 0; i < 256; i++)
	{
		printf("%02x", tv_plain[i]);

		if ((i + 1) % 32 == 0)
			printf("\n");
		else if ((i + 1) % 16 == 0)
			printf(" ");
	}
	printf("\n");
	for (int i = 0; i < 256; i++)
	{
		printf("%02x", tv_plain1[i]);

		if ((i + 1) % 32 == 0)
			printf("\n");
		else if ((i + 1) % 16 == 0)
			printf(" ");
	}
	Clear_SM4CTX(&mySM4CTX);
	return err;

}

int  Test_SM4OFB(void)
{

	SM4_CTX_Std mySM4CTX;

	static   unsigned char Sm4ALIGN(plofb[32]) = { 0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb
,0xcc,0xcc,0xcc,0xcc,0xdd,0xdd,0xdd,0xdd
,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff
,0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb };

	static unsigned char Sm4ALIGN(cp0ofb[64]) = {
	0xac, 0x32, 0x36, 0xcb, 0x86, 0x1d, 0xd3, 0x16, 0xe6, 0x41, 0x3b, 0x4e, 0x3c, 0x75, 0x24, 0xb7,
   0x1d, 0x01, 0xac, 0xa2, 0x48, 0x7c, 0xa5, 0x82, 0xcb, 0xf5, 0x46, 0x3e, 0x66, 0x98, 0x53, 0x9b,
   0x5d, 0xcc, 0xcd, 0x25, 0xa8, 0x4b, 0xa1, 0x65, 0x60, 0xd7, 0xf2, 0x65, 0x88, 0x70, 0x68, 0x49,
   0x33, 0xfa, 0x16, 0xbd, 0x5c, 0xd9, 0xc8, 0x56, 0xca, 0xca, 0xa1, 0xe1, 0x01, 0x89, 0x7a, 0x97, };
	static unsigned char Sm4ALIGN(keyofb[SM4_BLOCK_SIZE * 2]) = {
	 0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,   0xfe,0xdc,0xba,0x98, 0x76,0x54,0x32,0x10 ,
	 0xFE ,0xDC ,0xBA ,0x98 ,0x76 ,0x54 ,0x32 ,0x10 ,0x01 ,0x23 ,0x45 ,0x67 ,0x89 ,0xAB ,0xCD ,0xEF
	};
	static unsigned char Sm4ALIGN(ivofb[16]) = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07
	,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F };
	int i, err = 0;
	unsigned char Sm4ALIGN(tv_cipher[64]);
	unsigned char Sm4ALIGN(tv_plain1[64]);

	int ofboffset = 0;  //0 or 16  分别对应 example1 example2 
	u64i OFBlen = 27;  //<32 

	Init_SM4CTX(&mySM4CTX, keyofb + ofboffset, iMODE_SM4_OFB, ivofb);
	SM4_EncStd_OFB(tv_cipher, plofb, OFBlen, &mySM4CTX);
	err = memcmp(cp0ofb + ofboffset * 2, tv_cipher, OFBlen);
	printf("SM4 OFB standard  ENC Test %s \n", err ? "failed" : "passed");
	for (i = 0; i < OFBlen; i++)
		printf("%02x ", tv_cipher[i]); printf("\n");
	SM4_DecStd_OFB(tv_plain1, tv_cipher, OFBlen, &mySM4CTX);
	i = memcmp(plofb, tv_plain1, OFBlen);
	printf("SM4 OFB standard  DEC Test %s \n", i ? "failed" : "passed");
	err += i;
	for (i = 0; i < OFBlen; i++)
		printf("%02x ", tv_plain1[i]);  printf("\n");

	Clear_SM4CTX(&mySM4CTX);
	return err;
}


int  Test_SM4CFB128(void)
{

	SM4_CTX_Std mySM4CTX;

	static unsigned char Sm4ALIGN(cp0cfb128[32]) = {
	0xac, 0x32, 0x36, 0xcb, 0x86, 0x1d, 0xd3, 0x16, 0xe6, 0x41, 0x3b, 0x4e, 0x3c, 0x75, 0x24, 0xb7,
   0x69 ,0xd4 ,0xc5 ,0x4e ,0xd4 ,0x33 ,0xb9 ,0xa0 ,0x34,0x60  ,0x09 ,0xbe ,0xb3 ,0x7b ,0x2b ,0x3f };

	static unsigned char Sm4ALIGN(keyofb[SM4_BLOCK_SIZE * 2]) = {
	 0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,   0xfe,0xdc,0xba,0x98, 0x76,0x54,0x32,0x10 ,
	 0xFE ,0xDC ,0xBA ,0x98 ,0x76 ,0x54 ,0x32 ,0x10 ,0x01 ,0x23 ,0x45 ,0x67 ,0x89 ,0xAB ,0xCD ,0xEF
	};
	static unsigned char Sm4ALIGN(ivofb[16]) = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07
	,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F };

	static   unsigned char Sm4ALIGN(plofb[32]) = { 0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb
   ,0xcc,0xcc,0xcc,0xcc,0xdd,0xdd,0xdd,0xdd
   ,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff
   ,0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb };

	int i, err = 0;
	unsigned char Sm4ALIGN(tv_cipher[64]);
	unsigned char Sm4ALIGN(tv_plain[64]);
	u64i  dlen = 27;

	Init_SM4CTX(&mySM4CTX, keyofb, iMODE_SM4_CFB128, ivofb);
	SM4_EncStd_CFB128(tv_cipher, plofb, (u64i)dlen, &mySM4CTX);
	err = memcmp(cp0cfb128, tv_cipher, dlen);
	printf("SM4 CFB-128 standard  ENC Test %s \n", err ? "failed" : "passed");
	for (i = 0; i < dlen; i++)
		printf("%02x ", tv_cipher[i]); printf("\n");
	SM4_DecStd_CFB128(tv_plain, tv_cipher, (u64i)dlen, &mySM4CTX);
	i = memcmp(plofb, tv_plain, dlen);
	printf("SM4 CFB-128 standard  DEC Test %s \n", i ? "failed" : "passed");
	err += i;
	for (i = 0; i < dlen; i++)
		printf("%02x ", tv_plain[i]);  printf("\n");

	Clear_SM4CTX(&mySM4CTX);
	return err;
}


int  Test_SM4CFB64(void)
{

	SM4_CTX_Std mySM4CTX;
	static unsigned char Sm4ALIGN(keyofb[SM4_BLOCK_SIZE * 2]) = {
	 0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,   0xfe,0xdc,0xba,0x98, 0x76,0x54,0x32,0x10 ,
	 0xFE ,0xDC ,0xBA ,0x98 ,0x76 ,0x54 ,0x32 ,0x10 ,0x01 ,0x23 ,0x45 ,0x67 ,0x89 ,0xAB ,0xCD ,0xEF
	};
	static unsigned char Sm4ALIGN(ivofb[16]) = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07
	,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F };

	static   unsigned char Sm4ALIGN(plofb[32]) = { 0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb
   ,0xcc,0xcc,0xcc,0xcc,0xdd,0xdd,0xdd,0xdd
   ,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff
   ,0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb };

	int i, err = 0;
	unsigned char Sm4ALIGN(tv_cipher[64]);
	unsigned char Sm4ALIGN(tv_plain[64]);

	u64i dlen = 27;

	Init_SM4CTX(&mySM4CTX, keyofb, iMODE_SM4_CFB64, ivofb);
	SM4_EncStd_CFB64(tv_cipher, plofb, (u64i)dlen, &mySM4CTX);
	for (i = 0; i < dlen; i++)
		printf("%02x ", tv_cipher[i]); printf("\n");
	SM4_DecStd_CFB64(tv_plain, tv_cipher, (u64i)dlen, &mySM4CTX);
	i = memcmp(plofb, tv_plain, dlen);
	printf("SM4 CFB-64  standard  DEC Test %s \n", i ? "failed" : "passed");
	err += i;
	for (i = 0; i < dlen; i++)
		printf("%02x ", tv_plain[i]);  printf("\n");

	Clear_SM4CTX(&mySM4CTX);
	return err;
}

int  Test_SM4CFB8(void)
{

	SM4_CTX_Std mySM4CTX;
	static unsigned char Sm4ALIGN(keyofb[SM4_BLOCK_SIZE * 2]) = {
	 0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,
	 0xfe,0xdc,0xba,0x98, 0x76,0x54,0x32,0x10 ,
	 0xFE ,0xDC ,0xBA ,0x98 ,0x76 ,0x54 ,0x32 ,0x10 ,
	 0x01 ,0x23 ,0x45 ,0x67 ,0x89 ,0xAB ,0xCD ,0xEF
	};
	static unsigned char Sm4ALIGN(ivofb[16]) = {
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07
	,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F };

	static   unsigned char Sm4ALIGN(plofb[32]) = {
   0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb
   ,0xcc,0xcc,0xcc,0xcc,0xdd,0xdd,0xdd,0xdd
   ,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff
   ,0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb };

	int i, err = 0;
	unsigned char Sm4ALIGN(tv_cipher[64]);
	unsigned char Sm4ALIGN(tv_plain[64]);
	u64i dlen = 27;

	Init_SM4CTX(&mySM4CTX, keyofb, iMODE_SM4_CFB8, ivofb);
	SM4_EncStd_CFB8(tv_cipher, plofb, (u64i)dlen, &mySM4CTX);
	for (i = 0; i < dlen; i++)
		printf("%02x ", tv_cipher[i]); printf("\n");
	SM4_DecStd_CFB8(tv_plain, tv_cipher, (u64i)dlen, &mySM4CTX);
	i = memcmp(plofb, tv_plain, dlen);
	printf("SM4 CFB-8   standard  DEC Test %s \n", i ? "failed" : "passed");
	err += i;
	for (i = 0; i < dlen; i++)
		printf("%02x ", tv_plain[i]);  printf("\n");

	Clear_SM4CTX(&mySM4CTX);
	return err;
}

int  Test_SM4CFB1(void)
{

	SM4_CTX_Std mySM4CTX;
	static unsigned char Sm4ALIGN(keyofb[SM4_BLOCK_SIZE * 2]) = {
	 0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,
	 0xfe,0xdc,0xba,0x98, 0x76,0x54,0x32,0x10 ,
	 0xFE ,0xDC ,0xBA ,0x98 ,0x76 ,0x54 ,0x32 ,0x10 ,
	 0x01 ,0x23 ,0x45 ,0x67 ,0x89 ,0xAB ,0xCD ,0xEF
	};
	static unsigned char Sm4ALIGN(ivofb[16]) = {
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07
	,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F };

	static   unsigned char Sm4ALIGN(plofb[32]) = {
   0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb
   ,0xcc,0xcc,0xcc,0xcc,0xdd,0xdd,0xdd,0xdd
   ,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff
   ,0xaa,0xaa,0xaa,0xaa,0xbb,0xbb,0xbb,0xbb };

	int i, err = 0;
	unsigned char Sm4ALIGN(tv_cipher[64]);
	unsigned char Sm4ALIGN(tv_plain[64]);
	u64i dlen = 27;
	Init_SM4CTX(&mySM4CTX, keyofb, iMODE_SM4_CFB1, ivofb);
	SM4_EncStd_CFB1(tv_cipher, plofb, (u64i)dlen, &mySM4CTX);
	for (i = 0; i < dlen; i++)
		printf("%02x ", tv_cipher[i]); printf("\n");
	SM4_DecStd_CFB1(tv_plain, tv_cipher, (u64i)dlen, &mySM4CTX);
	i = memcmp(plofb, tv_plain, dlen);
	printf("SM4 CFB-1   standard  DEC Test %s \n", i ? "failed" : "passed");
	err += i;
	for (i = 0; i < dlen; i++)
		printf("%02x ", tv_plain[i]);  printf("\n");

	Clear_SM4CTX(&mySM4CTX);
	return err;
}


int  Test_SM4CTR(void)
{

	SM4_CTX_Std mySM4CTX;
	static unsigned char Sm4ALIGN(pl[256]) = {
   0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
   0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,
   0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,
   0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
   0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,
   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
   0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
   0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb
	};

	static unsigned char Sm4ALIGN(iv[16]) = {
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07
	,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F
	};

	static unsigned char Sm4ALIGN(recctr[256]) = {
	  0xac,0x32,0x36,0xcb,0x97,0x0c,0xc2,0x07
	 ,0x91,0x36,0x4c,0x39,0x5a,0x13,0x42,0xd1
	 ,0xa3,0xcb,0xc1,0x87,0x8c,0x6f,0x30,0xcd
	 ,0x07,0x4c,0xce,0x38,0x5c,0xdd,0x70,0xc7
	 ,0xf2,0x34,0xbc,0x0e,0x24,0xc1,0x19,0x80
	 ,0xfd,0x12,0x86,0x31,0x0c,0xe3,0x7b,0x92
	 ,0x6e,0x02,0xfc,0xd0,0xfa,0xa0,0xba,0xf3
	 ,0x8b,0x29,0x33,0x85,0x1d,0x82,0x45,0x14
	};

	unsigned char Sm4ALIGN(key[SM4_BLOCK_SIZE]) = {
   0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,
   0xfe,0xdc,0xba,0x98, 0x76,0x54,0x32,0x10
	};

	int i, err = 0;
	unsigned char Sm4ALIGN(tv_cipher[256]);
	unsigned char Sm4ALIGN(tv_cipher1[256]);
	unsigned char Sm4ALIGN(tv_plain[256]);
	unsigned char Sm4ALIGN(tv_plain1[256]);
	u64i  dlen = 32;

	Init_SM4CTX(&mySM4CTX, key, iMODE_SM4_CTR, iv);
	SM4_EncStd_CTR(tv_cipher, pl, (u64i)dlen, &mySM4CTX);
	err = memcmp(recctr, tv_cipher, dlen);
	printf("SM4 CTR standard  ENC Test %s \n", err ? "failed" : "passed");
	for (i = 0; i < dlen; i++)
		printf("%02x ", tv_cipher[i]); printf("\n");
	SM4_DecStd_CTR(tv_plain, recctr, (u64i)dlen, &mySM4CTX);
	i = memcmp(pl, tv_plain, dlen);
	printf("SM4 CTR standard  DEC Test %s \n", i ? "failed" : "passed");
	err += i;
	for (i = 0; i < dlen; i++)
		printf("%02x ", tv_plain[i]);  printf("\n");


	dlen = 256;
	for (int i = 0; i < 256; i++)
		tv_plain[i] = i;
	SM4_EncStd_CTR(tv_cipher, tv_plain, dlen, &mySM4CTX);
	SM4_EncStd_CTR(tv_cipher1, tv_plain, dlen, &mySM4CTX);
	//   outlen= SM4_DecNeon_CBC(tv_plain1, tv_cipher, dlen,&mySM4CTX);   

	for (int i = 0; i < 256; i++)
	{
		printf("%02x", tv_cipher[i]);

		if ((i + 1) % 32 == 0)
			printf("\n");
		else if ((i + 1) % 16 == 0)
			printf(" ");
	}
	printf("\n");
	for (int i = 0; i < 256; i++)
	{
		printf("%02x", tv_cipher1[i]);

		if ((i + 1) % 32 == 0)
			printf("\n");
		else if ((i + 1) % 16 == 0)
			printf(" ");
	}
	printf("\n");
	Clear_SM4CTX(&mySM4CTX);
	return err;
}



int TestAllfuns(void)
{
	Test_SM4ECB();
	Test_SM4CBC();
	Test_SM4OFB();
	Test_SM4CFB128();
	Test_SM4CFB64();
	Test_SM4CFB8();
	Test_SM4CFB1();
	Test_SM4CTR();

	return 0;
}